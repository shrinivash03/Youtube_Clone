 import { asyncHandler } from "../utils/asyncHandler.js";
 import {ApiError} from "../utils/ApiError.js" 
 import {User} from "../models/user.model.js"
 import {uploadOnCloudinary} from "../utils/cloudinary.js"
 import { ApiResponse } from "../utils/ApiResponse.js";
 import jwt from "jsonwebtoken";
import mongoose from "mongoose";
 

 const generateAccessAndRefreshToken= async(userId)=>{
     try{

        const user=await User.findById(userId)
        const accessToken = await user.generateAccessToken()
        const refreshToken = await user.generateRefreshToken() 

        console.log("accessToken:",accessToken)
        console.log("refreshToken",refreshToken)

        user.refreshToken=refreshToken
        await user.save({validateBeforeSave: false})// saving refresh token in db

        return {accessToken, refreshToken}

      } catch (error){
      throw new ApiError(500,"Something went wrong while generating access and refresh token")
     }
    }
     

 


const registerUser= asyncHandler(async (req,res)=> {
    //get user detail from frontend
    //validation - not empty
    //check if user alredy register: username, email
    //check for image , check for avtar
    //upload them to cloudinary ,avtar
    //create user object -create entry in db
    //remove password and refresh token field from response
    //check for user creation
    //return response


    const {fullName,email,username,password}=req.body
     //console.log("email:",email);
       
     //console.log("req.body");
     
     
     if(
        [fullName,email,username,password].some((field)=>
            field?.trim()=== "" )  //Checks if any field is empty or missing
        ){
            throw new ApiError(400,"All fields are required")   
        }

      const existedUser= await User.findOne({
        $or:[{ username }, { email }]
      })   
      //  $or: mongodb operator Checks in MongoDB if the user already exists.

 

      if(existedUser){
        throw new ApiError(409, "User with email or username")
      }

      const avatarLocalPath= req.files?.avatar[0]?.path;
      //const coverImageLocalPath= req.files?.coverImage[0]?.path;

    //   console.log(req.files);
    //classic way of writing using && 
     let coverImageLocalPath;
     if(req.files  && Array.isArray(req.files.
      coverImage) &&req.files.coverImage.length > 0){
        coverImageLocalPath = req.files.coverImage[0].path
      }

      // accesses the first file in the avatar array.
      // .path gets the path or URL of the uploaded file.
     // req.files is provided by upload middleware (e.g., multer)
     
     
     if(!avatarLocalPath){
        throw new ApiError(400,"Avatar file is requires")
      }

      const avatar=await uploadOnCloudinary(avatarLocalPath)
      const coverImage=await uploadOnCloudinary(coverImageLocalPath) 

      //uploading files on cloudinary 
     
   if(!avatar)
   {
    throw new ApiError(400,"Avatar file is required")
   }

   //we are not checking coverImage because in coverimage model the fiels required is false 

    const user= await User.create({
        fullName,
        avatar: avatar.url,
        coverImage: coverImage?.url || "",
        email,
        password,
        username:username.toLowerCase()
    })


    //User.create: This is a Mongoose method used to create a new document (user) in the MongoDB database
    //It inserts the provided data (fullName, avatar, email, etc.) into the User collection.



    const createdUser= await User.findById(user._id).select( 
        "-password -refreshToken"  //removing those things not required in db using -(negative sign)
    )

    /*
    ==> .select() method is used to include or exclude specific fields in the query result from the database.
    ==> Fetches the newly created user from the database using its unique ID (user._id), 
    which was auto-generated by MongoDB during the create() operation.
    ==>  Example: Fetching the name, email, and profilePicture for a user in a front-end request
    while avoiding sensitive fields like password or refreshToken.
    */
       
    if(!createdUser){
        throw new ApiError(500,"Something went wrong while registering thye user");
    }

   return res.status(201).json(
    new ApiResponse(200,createdUser,"User registerd Successfully")
   )

  //Send Response to the Client
   } )

       
//****  login user ****** 




const loginUser =asyncHandler(async(req,res)=>{
       //req body -> data
       //username or email
       //find the username
       //passwordcheck
       //access and refresh token
       //send cookie
 
        const {email,password,username}= req.body
        console.log("Request body:", req.body);
       
        if (!username && !email){
          throw new ApiError(500,"please enter valid username or email")

        } // checking username or email is not empty

      const user = await User.findOne({
          $or:[{username},{email}]
        }) //checking fields that are alredy in db


        if(!user){
          throw new ApiError(404, "User does not exist")
        } //if user not found

      
      const isPasswordValid= await user.isPasswordCorrect(password)

      if(!isPasswordValid){
        throw new ApiError(401, "Invalid User credentials ")
      } 


  const {accessToken,refreshToken}= await  generateAccessAndRefreshToken(user._id)
  
  const loggedInUser=await User.findById(user._id).select("-password -refreshToken")

    const options={
      httpOnly:true,
      secure:true,
    }
//cookie will never modified by frontend it can only by server 



   return res
   .status(200)
   .cookie("accessToken",accessToken,options)
   .cookie("refreshToken",refreshToken,options)
   .json(
        new ApiResponse(
          200,
          {
            user:loggedInUser,accessToken,refreshToken
          },
          "User logged In Successfully"
        )
   )


  })


const loggedOut = asyncHandler(async(req,res)=>{
          await User.findByIdAndUpdate(
            //==>findByIdAndUpdate: this is mongoose method use to find sinle documentin the User model 
            // collection by its _id and update it
            req.user._id,
            {
              $set:{
                refreshToken: undefined 

                // set is mongodb update operator and undefining means preventing it from being used to //generate new token.

              }
            },
            {
              new:true
            })
   //new:true => this tells mongoose to return the modified document after update has been applied         
          
           
          const options={
            httpOnly:true,  //this option when set on cookie makes cookie inaccessible to client-side
            secure:true    //this option ensure that cookie is sent only over HTTPS connection
          }

          return res
          .status(200)
          .clearCookie("accessToken", options) //this is express.js method res object that clear cookie of the client browser
          .clearCookie("refreshToken",options)
          .json(new ApiResponse(200,{},"User logged out "))
    })
  

  const refreshAccessToken= asyncHandler(async(req,res)=>{
    const incomingRefreshToken= req.cookies.refreshToken ||
    req.body.refreshToken //accessing token from cookies or body 

    if(!incomingRefreshToken){
      throw new ApiError(401,"unauthorised Request")
    }

  try{
      const decodedToken=jwt.verify(
        incomingRefreshToken, 
        process.env.REFRESH_TOKEN_SECRET
      )

//decodedToken: The result of verification. If valid, it contains data stored in the token (like a user ID).

      const user=await User.findById(decodedToken?._id)

      if(!user){
        throw new ApiError(401, "Invalid refresh token")
      }

      if(incomingRefreshToken!==user?.refreshToken)
      {
        throw new ApiError(401, "Refresh token is expired or used")
      }
// Checks if the refresh token sent matches the one stored in the userâ€™s record.
      const options={
        httpOnly:true,
        secure:true
      }
      const{accessToken,newRefreshToken}=await generateAccessAndRefreshToken(user._id)
//Calls a function to create a new access token and refresh token for the user.


      return res
      .status(200)
      .cookie("accessToken",accessToken,options)
      .cookie("refreshToken",newRefreshToken,options)
      .json(
        new ApiResponse(
          200,
          {
            accessToken,refreshToken:newRefreshToken
          },
          "Access token refreshed"
        )
      )
  } catch(error){
    throw new ApiError(401,error?.message || "Invalid refresh Token")
  }



   }) 
 

 const changeCurrentPasword=asyncHandler(async(req,res)=>{
  
    const {oldPassword, newPassword} =req.body


  const user= User.findById(req.user?._id)
  const isPasswordCorrect= await user.isPasswordCorrect(oldPassword)
   if(!isPasswordCorrect)
    {
    throw new ApiError(400,"Invalid Password")
   }
    user.password=newPassword
    user.save({validateBeforeSave: false})
   
   return res
   .status(200)
   .json(new ApiResponse(200,{},"Password changed successfully"))


   })

const getCurrentUser=asyncHandler(async(req,res)=>{
    return res
    .status(200)
    .json ( new ApiResponse (200,req.user,"current user fetched successfully"))
   })

  
 const updateAccountDetails=asyncHandler(async(req,res)=>{
    const {fullName,email}=req.body
    if(!fullName || !email)
    {
      throw new ApiError(400,"All fiels are required")
    }
   
   const user=await User.findByIdAndDelete(
    req.user?._id,
    {
      $set:{
        fullName,
        email:email
      } 
    },
    {new:true}
   ).select("-password")

   return res
   .status(200)
   .json(new ApiResponse(200,user,"Account details updated successfully"))
 })


 const updateUserAvatar=asyncHandler(async(req,res)=>
   {
  const avatarLocalPath= req.file?.path //file not files bcz we are manupulating single file
   
  if(!avatarLocalPath){
    throw new ApiError(400,"Avtar file is missing")
  }


  

    const avatar=await uploadOnCloudinary(avatarLocalPath)
     if(!avatar){
      throw new ApiError(400,"Error while uploading Avatar file on cloudinary")
      }

  //Fetch the old avatar URL from the DB
  const user = await User.findById(req.user?._id);
  const oldAvatarURL=user?.avatar?.url;
  

const updatedUser= await User.findByIdAndUpdate(
      req.user?._id,
      {
        $set:{
          avatar:avatar.url
        }
      },
      {new:true}
).select("-password")  // in db the password files is excluded

return res
.status(200)
.json(
  new ApiResponse(200,updatedUser,"Avatar image is updated successfully")
)

  

 })
 
 


 const updateUserCoverImage=asyncHandler(async(req,res)=>
  {
 const coverImageLocalPath= req.file?.path //file not files bcz we are manupulating single file
  
 if(!coverImageLocalPath){
   throw new ApiError(400,"Avtar file is missing")
 }
   const coverImage=await uploadOnCloudinary(coverImageLocalPath)
    if(!coverImage){
     throw new ApiError(400,"Error while uploading coverImage file on cloudinary")
    }
const user= await User.findByIdAndUpdate(
     req.user?._id,
     {
       $set:{
         avatar:coverImage.url
       }
     },
     {new:true}
).select("-password")  // in db the password files is excluded

return res
.status(200)
.json(
 new ApiResponse(200,user,"coverImage is updated successfully")
)

}) 


const getUserChannelProfile = asyncHandler(async(req, res) => {
  const {username} = req.params  //getting username data from url

  if (!username?.trim()) {
      throw new ApiError(400, "username is missing")
  }

  const channel = await User.aggregate([
      {
          $match: {
              username: username?.toLowerCase()
          }
      },
      {
          $lookup: {
              from: "subscriptions",
              localField: "_id",
              foreignField: "channel",
              as: "subscribers"
          }
      },
      {
          $lookup: {
              from: "subscriptions",
              localField: "_id",
              foreignField: "subscriber",
              as: "subscribedTo"
          }
      },
      {
          $addFields: {
              subscribersCount: {
                  $size: "$subscribers"
              },
              channelsSubscribedToCount: {
                  $size: "$subscribedTo"
              },
              isSubscribed: {
                  $cond: {
                      if: {$in: [req.user?._id, "$subscribers.subscriber"]},
                      then: true,
                      else: false
                  }
              }
          }
      },
      {
          $project: {
              fullName: 1,
              username: 1,
              subscribersCount: 1,
              channelsSubscribedToCount: 1,
              isSubscribed: 1,
              avatar: 1,
              coverImage: 1,
              email: 1

          }
      }
  ])

  //length we are using bcz channel is returning array
  if (!channel?.length) {
      throw new ApiError(404, "channel does not exists")
  }

  return res
  .status(200)
  .json(
      new ApiResponse(200, channel[0], "User channel fetched successfully")
  )
})

const getWatchHistory =asyncHandler(async(req,res)=>{
  const user=await  User.aggregate([
     {
      $match:{
        _id: new mongoose.Types.ObjectId(req.user._id)
  
      }
    },
      {
         $lookup:{
              from: "videos",
              localField:"watchHistory",
              foreignField:"_id",
              as:"watchHistory",
              pipeline:[
                {
                  $lookup:{
              from: "users",
              localField:"owner",
              foreignField:"_id",
              as:"owner",
              pipeline:[
                {
                  $project:{
                    fullName:1,
                    username:1,
                    avatar:1
                  }
                }
              ]

          } 
        },
        {
          $addFields:{
            owner:{
              $first: "owner"
            }
          }
        }
      ]
                   
    }
   }          
  ])

  return res
  .status(200)
  .json(new ApiResponse(200,user[0].watchHistory,
    "Watch history fetched successfully"
  ))
})
      
     


    





 export {registerUser,
  loginUser,loggedOut,generateAccessAndRefreshToken,
  refreshAccessToken,changeCurrentPasword,getCurrentUser,updateAccountDetails,
  updateUserAvatar,updateUserCoverImage,getUserChannelProfile,getWatchHistory



 } ;